package jbook

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
)

// Entry represents a journal entry.
type Entry struct {
	Title   string `json:"title"`
	Body    string `json:"body"`
	Date    string `json:"date"`
	Time    string `json:"time"`
	Starred bool   `json:"starred"`
}

// Journal represents the json-exported jrnl.
type Journal struct {
	Tags    map[string]int `json:"tags"`
	Entries []*Entry       `json:"entries"`

	Title       string
	Description string
}

// Export gets the data stored in a journal and stores it in a Journal struct.
func Export(journal string) *Journal {
	dir, err := ioutil.TempDir("", "")
	if err != nil {
		logger.Fatalf("Could not generate temp directory for exporting: %v", err)
	}

	tmp, err := ioutil.TempFile(dir, "")
	if err != nil {
		logger.Fatalf("Could not generate temp file for exporting: %v", err)
	}

	logger.Tracef("Created temp file %q for exporting", tmp.Name())

	cmd := exec.Command("jrnl", journal, "--export", "json", "-o", tmp.Name())

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin

	fmt.Println("")
	err = cmd.Run()
	fmt.Println("")

	if err != nil {
		logger.Fatalf("Error exporting journal with command %q, error: %v", cmd.String(), err)
	}

	var jrnl Journal

	bytes, _ := ioutil.ReadAll(tmp)
	err = json.Unmarshal(bytes, &jrnl)

	if err != nil {
		logger.Fatalf("Error parsing exported json: %v", err)
	}

	err = os.RemoveAll(dir)
	if err != nil {
		logger.Errorf("Error deleting temp directory for exporting (%s): %v", dir, err)
	}

	jrnl.Title = fmt.Sprintf("Journal ('%s')", journal)
	jrnl.Description = fmt.Sprintf("Journal web page generated by jbook.")

	return &jrnl
}

// CreateSource converts the journal into an mdBook format ready for conversion by the mdbook tool.
func CreateSource(journal *Journal, location string) string {
	var dir string
	var err error

	if location != "" {
		dir = location

		err = os.MkdirAll(location, 0755)
		if err != nil {
			logger.Fatalf("Error creating output directory: %v", err)
		}

	} else {
		dir, err = ioutil.TempDir("", "")
		if err != nil {
			logger.Fatalf("Could not generate temp directory for creating mdBook: %v", err)
		}
	}

	f, err := os.Create(path.Join(dir, "book.toml"))
	if err != nil {
		logger.Fatalf("Could not create `book.toml` file: %v", err)
	}

	config := Config(journal)
	f.Write([]byte(config))

	err = os.MkdirAll(path.Join(dir, "src", "entries"), 0755)
	if err != nil {
		logger.Fatalf("Could not create 'src/entries' directory: %v", err)
	}

	f, err = os.Create(path.Join(dir, "src", "SUMMARY.md"))
	if err != nil {
		logger.Fatalf("Could not create `SUMMARY.md` file: %v", err)
	}

	summary := Summary(journal)
	f.Write([]byte(summary))

	f, err = os.Create(path.Join(dir, "src", "entries", "README.md"))
	if err != nil {
		logger.Fatalf("Could not create `entries/README.md` file: %v", err)
	}

	readme := EntriesReadme()
	f.Write([]byte(readme))

	for i, entry := range journal.Entries {
		name := fmt.Sprintf("%d.md", i)

		f, err = os.Create(path.Join(dir, "src", "entries", name))
		if err != nil {
			logger.Fatalf("Could not create `entries/%s` file: %v", name, err)
		}

		data := FormatEntry(entry)
		f.Write([]byte(data))
	}

	logger.Infof("Created mdbook source at %q", dir)
	return dir
}

// Build runs the mdBook build command and moves it to the specified directory.
func Build(indir, outdir string) string {
	var cmd *exec.Cmd

	if outdir != "" {
		cmd = exec.Command("mdbook", "build", indir, "-d", outdir)
	} else {
		cmd = exec.Command("mdbook", "build", indir)
	}

	logger.Infof("Building book with command %q", cmd.String())

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin

	fmt.Println("")
	err := cmd.Run()
	fmt.Println("")

	if err != nil {
		logger.Fatalf("Error building book using `mdbook`.")
	}

	var dir string
	if outdir != "" {
		dir = path.Join(outdir, "book")
	} else {
		dir = path.Join(indir, "book")
	}

	logger.Infof("Success! Built book using mdbook tool, avaliable at %s", dir)

	return dir
}
