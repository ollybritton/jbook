package jbook

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"os/exec"
	"path"
	"strings"
	"time"
)

// Entry represents a journal entry.
type Entry struct {
	Title   string
	Body    string
	Starred bool

	Date time.Time

	offset time.Time
}

// UnmarshalJSON will unmarshal a JSON entry.
func (e *Entry) UnmarshalJSON(j []byte) error {
	var rawStrings map[string]interface{}

	err := json.Unmarshal(j, &rawStrings)
	if err != nil {
		return err
	}

	for k, v := range rawStrings {
		switch v := fmt.Sprint(v); strings.ToLower(k) {
		case "title":
			e.Title = v

		case "body":
			e.Body = v

		case "starred":
			e.Starred = v == "true"

		// f*** you parsing dates in go
		case "date":
			e.Date, err = time.Parse("2006-01-02", v)
			if err != nil {
				return err
			}

		case "time":
			e.offset, err = time.Parse("15:04", v)
			if err != nil {
				return err
			}
		}
	}

	e.Date = time.Date(e.Date.Year(), e.Date.Month(), e.Date.Day(), e.offset.Hour(), e.offset.Minute(), 0, 0, time.Local)
	return nil
}

// TitleDate returns a formatted date that is suitable for use in the sidebar of the mdbook.
func (e *Entry) TitleDate() string {
	return e.Date.Format("2006-01-02 @ 15:04 PM")
}

// FileDate returns a formatted date that is suitable for use as a filename.
func (e *Entry) FileDate() string {
	return e.Date.Format(time.RFC3339)
}

// Journal represents the json-exported jrnl.
type Journal struct {
	Tags    map[string]int `json:"tags"`
	Entries []*Entry       `json:"entries"`

	Title       string
	Description string
}

// Export gets the data stored in a journal and stores it in a Journal struct.
func Export(journal string) *Journal {
	dir, err := ioutil.TempDir("", "")
	if err != nil {
		logger.Fatalf("Could not generate temp directory for exporting: %v", err)
	}

	tmp, err := ioutil.TempFile(dir, "")
	if err != nil {
		logger.Fatalf("Could not generate temp file for exporting: %v", err)
	}

	logger.Tracef("Created temp file %q for exporting", tmp.Name())

	cmd := exec.Command("jrnl", journal, "--export", "json", "-o", tmp.Name())

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin

	fmt.Println("")
	err = cmd.Run()
	fmt.Println("")

	if err != nil {
		logger.Fatalf("Error exporting journal with command %q, error: %v", cmd.String(), err)
	}

	var jrnl Journal

	bytes, _ := ioutil.ReadAll(tmp)
	err = json.Unmarshal(bytes, &jrnl)

	if err != nil {
		logger.Fatalf("Error parsing exported json: %v", err)
	}

	err = os.RemoveAll(dir)
	if err != nil {
		logger.Errorf("Error deleting temp directory for exporting (%s): %v", dir, err)
	}

	jrnl.Title = fmt.Sprintf("Journal ('%s')", journal)
	jrnl.Description = fmt.Sprintf("Journal web page generated by jbook.")

	return &jrnl
}

// CreateSource converts the journal into an mdBook format ready for conversion by the mdbook tool.
func CreateSource(journal *Journal, location string) string {
	var dir string
	var err error

	if location != "" {
		dir = location

		err = os.MkdirAll(location, 0755)
		if err != nil {
			logger.Fatalf("Error creating output directory: %v", err)
		}

	} else {
		dir, err = ioutil.TempDir("", "")
		if err != nil {
			logger.Fatalf("Could not generate temp directory for creating mdBook: %v", err)
		}
	}

	f, err := os.Create(path.Join(dir, "book.toml"))
	if err != nil {
		logger.Fatalf("Could not create `book.toml` file: %v", err)
	}

	config := Config(journal)
	f.Write([]byte(config))

	err = os.MkdirAll(path.Join(dir, "src", "entries"), 0755)
	if err != nil {
		logger.Fatalf("Could not create 'src/entries' directory: %v", err)
	}

	f, err = os.Create(path.Join(dir, "src", "SUMMARY.md"))
	if err != nil {
		logger.Fatalf("Could not create `SUMMARY.md` file: %v", err)
	}

	summary := Summary(journal)
	f.Write([]byte(summary))

	f, err = os.Create(path.Join(dir, "src", "entries", "README.md"))
	if err != nil {
		logger.Fatalf("Could not create `entries/README.md` file: %v", err)
	}

	readme := EntriesReadme()
	f.Write([]byte(readme))

	for _, entry := range journal.Entries {
		name := fmt.Sprintf("%s.md", entry.FileDate())

		f, err = os.Create(path.Join(dir, "src", "entries", name))
		if err != nil {
			logger.Fatalf("Could not create `entries/%s` file: %v", name, err)
		}

		data := FormatEntry(entry)
		f.Write([]byte(data))
	}

	logger.Infof("Created mdbook source at %q", dir)
	return dir
}

// Build runs the mdBook build command and moves it to the specified directory.
func Build(indir, outdir string) string {
	var cmd *exec.Cmd

	if outdir != "" {
		cmd = exec.Command("mdbook", "build", indir, "-d", outdir)
	} else {
		cmd = exec.Command("mdbook", "build", indir)
	}

	logger.Infof("Building book with command %q", cmd.String())

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin

	fmt.Println("")
	err := cmd.Run()
	fmt.Println("")

	if err != nil {
		logger.Fatalf("Error building book using `mdbook`.")
	}

	var dir string
	if outdir != "" {
		dir = path.Join(outdir, "book")
	} else {
		dir = path.Join(indir, "book")
	}

	logger.Infof("Success! Built book using mdbook tool, avaliable at %s", dir)

	return dir
}
